# 0.基础知识

#### 1.认识时间复杂度

> 常数时间的操作

一个操作如果和样本的数据量没有关系，每次都是固定时问内完成的操作，叫做**常数操作**。

**时间复杂度**为一个算法流程中，常数操作数量的一个指标。常用O(读作big  O) 来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。
在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为O (f(N)）。
评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

> 在算法复杂度分析中，log 通常表示以 **2** 为底的对数



#### 2.关于异或

> 同为0，异为1
>
> 如：0^0=0,0^1=1.

满足结合律和交换律。



#### 3.位运算

> 位运算是最快的算法

##### 1)提取出最右侧的1

```c++
int rightOne=eor&(~eor+1);
```

如图：

![屏幕截图 2024-07-01 223705](E:\代码笔记\笔记图片保存\屏幕截图 2024-07-01 223705.png)



#### 4.关于对数器

> 对数器的概念

1.有一个你想要测的方法a；
2.实现一个绝对正确但是复杂度不好的方法b；
3.实现一个随机样本产生器；
4.实现对比算法a和b的方法；
5.把方法a和方法b比对多次来验证方法a是否正确；
6.如果有一个样本使得比对出错，打印样本分析是哪个方法出错；
7.当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

```c++
package com.bean.bubble_sort;

import java.util.Arrays;

public class BubbleSorted {
    public static void bubbleSort(int arr[]) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int end = arr.length-1; end > 0; end--) {
            for (int i = 0; i < end; i++) {
                if (arr[i] > arr[i+1]) {
                    swap(arr, i, i+1);
                }
            }
        }
    }

    public static void swap(int[] arr, int left, int right) {
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
    }
    //正确的排序方法
    public static void rightSort(int[] arr) {
        Arrays.sort(arr);
    }

    //生成一个随机大小，最大数随机的数组
    public static int[] generateRandomArray(int maxSize, int maxNum) {
        int[] arr = new int[(int) ((maxSize+1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random()*(maxNum+1)) - (int)(Math.random()*maxNum);
        }
        return arr;
    }

    //复制当前数组的一个样本
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] newArray = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            newArray[i] = arr[i];
        }
        return newArray;
    }

    //判断两个数组是否完全相同
    public static boolean isEquals(int[] arr1, int[] arr2) {
        if (arr1.length != arr2.length) {
            return false;
        }
        if (arr1 != null && arr2 == null || arr1 == null && arr2 != null) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        return true;
    }

    //打印数组
    public static void printArray(int[] arr) {
        if(arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]+" ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int testTims = 10000;//测试次数
        int maxSize = 20;//最大测试容量
        int maxNum = 20;//最大测试数据
        boolean euqals = true;
        for (int i = 0; i < testTims; i++) {
            int[] arr1 = generateRandomArray(maxSize,maxNum);
            int[] arr2 = copyArray(arr1);//这两个数组除了
            //数值相同内存地址完全没关系，请看copyArray()方法实现
            bubbleSort(arr1);//用自己的算法排序
            rightSort(arr2);//用java.util.Arrays包的排序算法排序
            if (!isEquals(arr1,arr2)) {//比较是否相同
                euqals = false;//一旦有不一样的值就设为false;
                break;
            }
        }
        System.out.println(euqals ? "Success:恭喜你！没毛病！" : "Error：抱歉，有错误" );//没错就恭喜，有错就报错
        int[] newArr = generateRandomArray(maxSize, maxNum);
        printArray(newArr);//没排序的数组打印出来
        bubbleSort(newArr);//排序后
        printArray(newArr);//再次打印，程序员自己看看有没有毛病
    }
}
```



#### 5.剖析递归行为和递归行为时间复杂度的估算(Master定理)

有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的：

用递归方法找一个数组中的最大值，系统上到底是怎么做的？
master公式的使用:**T (N)= a*T (N/b) + O (N^d)**

1)1og (b,a)>d  -> 复杂度为O(N^1og (b,a)）

2)1og (6,a)=d -> 复杂度为O(N^d * 1ogN)

3)1og (b,a)<d -> 复杂度为O(N^d)



#### 6.比较器

> c++里面也叫重载运算符
>
> （1）比较器可以应用在一些不规则的按照自己定义的规则进行排序的程序中，对于复杂的排序，多个方面的比较可以使用比较器减少代码量。
>
>  (2)比较器也可以应用到内置堆排序里面，java系统默认的是按照小根堆排序，也可以改成大根堆排序。

```c++
//返回负数的时候，第一个参数排在前面
//返回正数的时候，第二个参数排在前面
//返回0的时候，谁在前面无所谓
```



#### 7.哈希表

[C++ 哈希表 - CSDN App](http://t.csdnimg.cn/ho8Rc)

> 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。**哈希表本质上是个数组。**

> **简单介绍：**

**1）**哈希表在使用层面上可以理解为一种集合结构

**2）**如果只有key，没有伴随数据value，可以使用HashSet结构(C++中叫UnOrderedSet)

**3）**如果既有key，又有伴随数据value，可以使用HashMap结构(C++中叫UnOrderedMap)

**4）**有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事

**5）**使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为0(1)，但是常数时间比较大

**6）**放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小

**7）**放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小



##### 7.1 unordered_map的用法

> 是一个关联容器，内部采用的是hash表结构，拥有快速检索的功能。

- 特性

1. 关联性：通过key去检索value，而不是通过绝对地址（和顺序容器不同）
2. 无序性：使用hash表存储，内部无序
3. Map : 每个值对应一个键值
4. 键唯一性：不存在两个元素的键一样
5. 动态内存管理：使用内存管理模型来动态管理所需要的内存空间



- 模版

> 官方定义

```c++
template < class Key,                                    // unordered_map::key_type
           class T,                                      // unordered_map::mapped_type
           class Hash = hash<Key>,                       // unordered_map::hasher
           class Pred = equal_to<Key>,                   // unordered_map::key_equal
           class Alloc = allocator< pair<const Key,T> >  // unordered_map::allocator_type
           > class unordered_map;
```

> 具体使用

```c++
unordered_map<const Key, T> map;        //主要使用的是模版的前两个参数<键，值>

unordered_map<ListNode*，int>           //key值还可以是链表节点
```



- 迭代器

> 是一个指针，指向这个元素，通过迭代器来取得它的值

```c++
unordered_map<Key,T>::iterator it;
(*it).first;             // the key value (of type Key)
(*it).second;            // the mapped value (of type T)
(*it);                   // the "element value" (of type pair<const Key,T>) 
```

例如：

```c++
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;
int main()
{
    //创建 umap 容器
    unordered_map<string, string> umap{
        {"Python教程","http://c.biancheng.net/python/"},
        {"Java教程","http://c.biancheng.net/java/"},
        {"Linux教程","http://c.biancheng.net/linux/"} };
    cout << "umap 存储的键值对包括：" << endl;
    //遍历输出 umap 容器中所有的键值对
    for (auto iter = umap.begin(); iter != umap.end(); ++iter) {
        cout << "<" << iter->first << ", " << iter->second << ">" << endl;
    }
    //获取指向指定键值对的前向迭代器
    unordered_map<string, string>::iterator iter = umap.find("Java教程");
    cout << "umap.find(\"Java教程\") = " << "<" << iter->first << ", " << iter->second << ">" << endl;
    return 0;
}
```



- 功能函数

unordered_map的构造方式有几种:

1. 构造空的容器
2. 用数组构造
3. 复制构造
4. 范围构造

```c++
unordered_map<int,int>hashmap_1;//构造空的容器
unordered_map<string,int>hashmap_2{{"Jan",44}, {"Jim", 33}, {"Joe", 99}};//直接构造
unordered_map<string,int>hashmap_3(hashmap_2);// 复制初始化
unordered_map<string,int>hashmap_4(hashmap_2.begin(),hashmap_2.end());// 范围初始化
```

例如：

```c++
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

typedef unordered_map<string,string> stringmap;

int main ()
{
  stringmap first;                              // 空
  stringmap second = {{"apple","red"},{"lemon","yellow"}};       // 用数组初始
  stringmap third = {{"orange","orange"},{"strawberry","red"}};  // 用数组初始
  stringmap fourth (second);                    // 复制初始化
  stringmap sixth (fifth.begin(),fifth.end());  // 范围初始化

  cout << "sixth contains:";
  for (auto& x: sixth) cout << " " << x.first << ":" << x.second;
  cout << endl;

  return 0;
}
```



#### 8.有序表

> **简单介绍:**

**1）**有序表在使用层面上可以理解为一种集合结构

**2）**如果只有key，没有伴随数据value，可以使用TreeSet结构(C++中叫OrderedSet)

**3）**如果既有key，又有伴随数据value，可以使用TreeMap结构(C++中叫OrderedMap)

**4）**有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事

**5）**有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织5）红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同

**6）**放入有序表的东西，如果是基础类型，内部按值传递

**7）**放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小

**8）**不管是什么底层具体实现，只要是有序表， 都有以下固定的基本功能和固定的时间复杂度



> **固定操作:**

1）void put(K key，V value):将一个(key，value）记录加入到表中，或者将key的记录更新成value。

2）V get(K key):根据给定的key，查询value并返回。

3）void remove(K key):移除key的记录。

4）boolean containsKey(K key):询问是否有关于key的记录。

5）K firstKey():返回所有键值的排序结果中，最左（最小）的那个。

6）K lastKey():返回所有键值的排序结果中，最右（最大）的那个。

7）K floorKey (K key):如果表中存入过key，返回key;否则返回所有键值的排序结果中，key的前一个。

8）K ceilingKey(K key):如果表中存入过key，返回key;否则返回所有键值的排序结果中，key的后一个。

以上所有操作时间复杂度都是O(logN)，N为有序表含有的记录数。



#### 9.坐标系的表示方法

算法竞赛涉及的坐标系表示方法源点是在左上角的，y轴指向右侧，x轴指向下侧。



# 一、STL标准库

**头文件**

```c++
#include<algorithm>   //c++的标准算法库
```

## 1.容器

### 容器的共通操作

- equality(==)和inequality(!=)运算符，返回true和false
- assignment(=)运算符，将某个容器复制给另一个容器
- empty()会在容器无任何元素时返回true，否则返回false
- size()返回容器内目前持有的元素个数
- clear()删除所有元素
- 每个容器都提供了begin()和end()两个函数，分别返回容器内的第一个元素和最后一个元素的下一个iterator(泛型指针)
- insert()用以插入元素，erase()用以删除元素

### 数组`<vector>`

**1.vector`<int>` v(N,i)**  

```c++
#include<vector>      //头文件
vector<int> v(N,i);
```

建立一个可变长度数组v，元素类型为int；该可变数组自开始有N个元素，每个元素初始化为i。可以省略i(默认值为0)，也可以把(N，i)同时省略，此时这个数组的长度就是0。内部元素类型可以替换成其他的类型，比如double。

**2.v.push_back(a)**

```c++
v.push_back(a);
```

将元素a插入到数组v的末尾，并增加数组长度。

**3.v.size()**

返回数组v的长度

**4.v.resise(n,m)**

```c++
v.resise(n,m);
```

重新调整数组大小为n，如果n比原来的小，则删除多余的信息；如果n比原来大，则新增的部分都初始化为m，其中m是可以忽略的。

**5.vector`<int>`::iterator it**

定义一个名字叫作it的迭代器

**6.v.begin(),v.end()**

v.begin()返回数组v首元素。

v.end()返回数组v首元素末尾的下一个元素的指针(迭代器)。这个指针有点类似于空指针，不指向任何元素。



### 栈 `<stack>`

头文件 `#include<stack>`

**1.常用方法**

```c++
stack<int> s;    //建立一个栈s，其内部元素类型是int。
s.push(a);       //将元素a压入栈s
s.pop();         //将s的栈顶元素弹出
s.top();         //查询s的栈顶元素
s.size();        //查询s的元素个数
s.empty();       //查询s是否为空
```

### 队列 `<queue>`

头文件`#include<queue>`

**1.常用方法**

```c++
queue<int> q;     //建立一个队列q，其内部元素类型是int
q.push(a);        //将元素a插入到队列q的末尾
q.pop();          //删除队列q的队首元素
q.front();        //查询q的队首元素
q.back();         //查询q的队尾元素
q.size();         //查询q的元素个数
q.empty();        //查询q是否为空
```



## 2.泛型搜索算法

### find()函数

> 用于搜索**无序集合**中是否存在某值

find函数在使用的时候需要三个参数：起始位置First和终止位置Last（非必需），需要搜索的值Value（必需）
例子如下：

```c++
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
  std::vector<int> vec = {4, 2, 7, 5, 9, 1, 8};
  int target = 5;

  auto it = std::find(vec.begin(), vec.end(), target);//分别确定起始位置，终止位置（即遍历vector）

  if (it != vec.end()) {
    std::cout << "找到目标元素 " << target << " 在向量中的位置: " << std::distance(vec.begin(), it) << std::endl;
  } else {
    std::cout << "未找到目标元素 " << target << std::endl;
  }

  return 0;
}
```

该函数返回指向第一次出现指定元素的迭代器 ,若没有搜索到想要的值，则返回Last.



### binary_search()函数

> 用于**有序集合**的搜索，效率比binary search差

函数接收：起始位置First，终止位置Last，需要查找的值Value
该函数常用于**二分查找**，可以提高查找的效率，使算法更加高效，该算法的时间复杂度为O(log n)
例子如下：

```c++
#include <iostream>
#include <vector>
#include <algorithm>
int main() {
  std::vector<int> vec = {1, 3, 5, 7, 9, 11, 13, 15, 17};
  int target = 7;
  bool found = std::binary_search(vec.begin(), vec.end(), target);
  if (found) {
    std::cout << "目标元素 " << target << " 存在于向量中" << std::endl;
  } else {
    std::cout << "目标元素 " << target << " 不存在于向量中" << std::endl;
  }
  return 0;
}
```

 如果存在Value，则函数返回true，否则返回false.

### count()函数

> 返回**数值相符**的元素数目

同find()函数一样，count()函数接收三个参数：起始位置First，终止位置Last，搜索的特定值Value
例子如下：

```c++
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
  std::vector<int> myVector = {1, 2, 3, 4, 1, 2, 1, 5, 2};
  // 统计向量中元素2的出现次数
  int countOf2 = std::count(myVector.begin(), myVector.end(), 2);
  std::cout << countOf2 << std::endl;
  return 0;
}
```

 该函数返回特定值Value重复出现的次数，若没有查找到Value，则返回0



### search()函数

> 用于比对某个容器内**是否存在某个子序列**。

例如给定序列{1,3,5,7,2,9}，如果搜索子序列{5,7,2}，则search()会返回一个iterator指向子序列初始处。如果子序列不存在，就返回一个iterator指向容器末尾。



### adjacent_find()函数

> 使用该函数，将会在给定的范围（First和Last之间）**查找相邻的元素**，如果查找到相邻的重复元素，则返回指向第一个重复元素的迭代器，否则返回Last

该函数接收两个参数：起始位置First和终止位置Last



### find_if()函数

该函数接收三个参数：起始位置First，终止位置Last，一个可调用对象P（用于检查元素是否符合特定条件）
例子如下：

```c++
#include <iostream>
#include <vector>
#include <algorithm>

bool isGreaterThanThree(int num) {
  return num > 3;
}
int main() {
  std::vector<int> myVector = {1, 2, 3, 4, 5, 6};
  // 查找大于3的第一个元素
  auto it = std::find_if(myVector.begin(), myVector.end(), isGreaterThanThree);
  if (it != myVector.end()) {
    std::cout << "First element greater than 3: " << *it << std::endl;
  } else {
    std::cout << "No element greater than 3 found in the vector." << std::endl;
  }
  return 0;
}
```

在这个例子中，程序设计了一个寻找小于3的函数，并通过find_if()函数实现
如果找到符合条件的元素，则返回指向该元素的迭代器，否则返回Last



### copy()函数

> **复制**一份容器

```c++
copy(vec.begin(),vec.end(),temp.begin());
//vec和temp是数组
```

接受两个iterator，标示出复制范围。第三个iterator指向复制行为的目的地。



## 3.使用Map

> 被定义为一对(pair)数值，其中的key通常是个字符串。

头文件

```c++
#include<map>
//建立一份map
map<string,int> words;
//<>里面的第一个参数是键类型，第二个参数是值的类型
```

- map的find()函数-->与泛型算法不同

​			若key已放入其中，返回一个iterator，指向key/value形成的一个pair，反之返回end()

- map的count()函数，返回某特定项在map内的个数



例题：

[P3613 【深基15.例2】寄包柜](https://www.luogu.com.cn/problem/P3613)

> 建立二维映射

```c++
#include<cstdio>
#include<iostream> 
#include<map>//引用STL里的map库
using namespace std;
map<int,map<int,int> > a;//建立二维映射
int main(){
	int n,q,x,y,k,z;
    cin>>n>>q;//输入寄包柜个数及询问次数
    for(int i=1;i<=q;++i){//循环q次
        scanf("%d%d%d",&k,&x,&y);//先输入k,x,y
        if(k==1){//存放操作
            scanf("%d",&z);//继续输入
            a[x][y]=z;//建立一次映射
        }
        else{//查询操作
            printf("%d\n",a[x][y]);//直接输出所映射的值
        }
    }
	return 0;
}
```



## 4.使用Set

> 如果我们想知道某值是否存在于某个集合内，就可以使用set

```c++
#include<set>
//建立一份set
set<string> word_exclusion
```



## 5常用函数

### reverse()函数

> 用法：

```c++
#include<algorithm>
reverse(数组名.begin(),数组名.end())；
```

### STL.vector()函数

> vector的成员函数end()返回的迭代器指向向量的最后一个元素之后，而不是最后一个元素，因此，无法从end()返回的迭代器获得元素值。这可能看起来有悖直观，但是能很好地用于遍历容器的循环中。
>

**1.使用capacity()成员函数**

> capacity()返回向量的容量，即在程序必须为其重新分配更多内存之前，向量所能容纳的元素数目。

```c++
//下面的代码可以看出来size()与capacity()的区别
cout <<"Creating a element vector to hold scores.\n";
vector<int> scores(10,0);     //initialize all 10 elements to 0
cout <<"Vector size is:"<<scores.size()<<endl;
cout <<"Vector capacity is:"<<scores.capacity()<<endl;
cout <<"Adding a scores.\n";
scores.push_back(0);
cout <<"Vector size is :"<<scores.size()<<endl;
cout <<"Vector capacity is:"<<scores.capacity()<<endl;
```

**2.使用reserve()成员函数**

> reserve()成员函数将向量的容量扩充至给定实参的大小。reserve()允许程序员控制重新分配额外内存的时机。

```c++
vector<int> scores(10,0);
scores.reserve(20);
```

### next_permutation()函数

```c++
next_permutation(start,end);
```

是algorithm标准库中的一个函数，它可以表示[start,end)内存的数组中产生严格的下一个字典序排列。

[P1706 全排列问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1706)





# 二、常用数学函数

## 1.gcd(number1,number2,...)

> 用于计算两个或多个整数的最大公约数

这个函数的参数个数可以说1到225个

## 2.sort()算法

> 对定区间所有元素进行排序，且执行效率较高

```c++
sort(start,end,cmp);
//头文件为#include <algorithm>或#include<bits/stdc++.h>
//一般要加上using std::sort或直接using namespace std;(不建议)
```

（1）start表示要排序数组的起始地址；迭代器的起始位置，对于数组来说就是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。
（2）end表示数组结束地址的下一位；迭代器的结束位置，即首地址加上数组的长度n（代表尾地址的下一地址）。
（3）**cmp用于规定排序的方法**，可不填，**默认升序**(从小到大)。迭代器的结束位置，即首地址加上数组的长度n（代表尾地址的下一地址）。

注：cmp可以是自己创造的一个**bool函数**



## 3.memset函数

```c++
memset(b,0,sizeof(b));      
//第一个参数为数组，第二个参数为要设置成的字符或数字，第三个参数为数组长度
```



## 4.sqrt()函数--平方根

```c++
//文件头 <cmath>
sqrt(t);
//t为一个数，是double型的，否则会强制转换为double型的
```



## 5.最小公倍数和最大公约数

最大公因数和最小公倍数之间还存在着性质：两个自然数的乘积等于这两个自然数的**最大公约数和最小公倍数的乘积**。

> 1.最大公约数--辗转相除法

用较小数除较大数， 再用出现的余数（第二余数）去除第一余数， 如此反复，直到最后余数是0为止。 如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。

```c++
//最大公因数-辗转相除法-递归
private static int gcd(int n,int m)
{
    return n%m ==0?m:gcd(m,n%m);
}

//辗转相除法：返回公约数
public static int Method(int x,int y)
{
     int a,b,c;
     a=x;
     b=y;
     while(b!=0)
     {
         c=a%b;
         a=b;
         b=c;
     }
        return a;
}

```



> 2.最大公约数--相减法

```c++
//相减法
public static int Subtraction(int x,int y)
{
    while(x!=y)
    {
       if(x>y)
       {
          x=x-y;
        }
        else
        {
          y=y-x;
        }
     }
    return x;
}
```



> 3.穷举法

```c++
//穷举法  求公约数
public static int divisor(int x,int y)
{
    int z;
    for(z=x;z>0;z--)
    {
        if(x%z==0&&y%z==0)
        {
            break;
        }
     }
        return z;
}

//求公倍数
public static int multiple(int x,int y)
{
     int z;
     for(z=x;;z++)
     {
        if(z%x==0&&z%y==0)
        {
             break;
        }
      }
        return z;
}
```



## 6.向下取整--floor()函数

```c++
floor(number,significance);
//number为要舍入的数值
//significance为要舍入到的倍数
```



## 7.__builtin_popcount() 

直接返回一个数二进制下1的个数。

[P1036 [NOIP2002 普及组] 选数](https://www.luogu.com.cn/problem/P1036)



## 8.判断是否为质数

```c++
bool check(int n) {
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0)
			return 0;
	}
	return 1;
}
```



## 9.判断数字的位数

1.数字分割法

```c
#include <stdio.h>
void main()
{
    int x,b=0;
    scanf("%d",&x);
    while(x>0)
    {
       	x=x/10;
        b++;
    }
    printf("%d ",b);
}
```

2.log10法

```c++
#include<iostream>
#include<cmath>
using namespace std;
int main() 
{
    int n;
    cin>>n;
    cout<<(int)(log10(n))+1;           //important
    return 0;
}
```



## 10.判断回文数

```c++
bool huiwen(int x)//判断回文
{
	int k,len=0,j;
	while(x!=0)
	{
		len++;
		s[len]=x%10;
		x/=10;
	}
	if(len==1) 
	{
		s[len]=0;
		return 1;
	}
	for(k=1;k<=len/2;k++)
			if(s[k]!=s[len-k+1]) return 0;
	for(k=1;k<=len;k++) s[k]=0;
	return 1;
}
```



# 三、常用技巧

#### 1.判断为偶数

```c++
if(i&1)  //按位与
```



#### 2.关流模版

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	return 0;
}
```



#### 3.字符与数字之间的转换

> 1.字符转换为数字

```c++
 char w;
 cin >>w;
 int result;
 result=w-'a'+1;
```

> 2.数字转换为字符

```c++
int a;
cin >> a;
char result;
result = a + 'a' - 'a';
```

> 3.大写字母与小写字母之间的转换

```c++
//大写转小写(+32转换为小写)
int t,m;
cin >>t;
m=t-'A'+'a';
cout <<m<<endl;

//小写转大写(-32转换为大写)
int t,m;
cin >>t;
m=t-'a'+'A';
cout <<m<<endl;
```



#### 4.快读

```c++
inline void in(int &a){ //快速读入
    a=0;char ch=getchar();
    while(ch<'0'||ch>'9')   //得到数字字符
        ch=getchar();
    while(ch>='0'&&ch<='9'){
        a=(a<<1)+(a<<3)+(ch^48);
        ch=getchar();
    }
}

int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*f;
}
```



#### 5.控制浮点数的输出格式

[数据格式控制函数：setprecision() 、fixed()和setw()函数的使用](http://t.csdnimg.cn/lGSP3)

##### 5.1 方法setprecision( )

> 1.设置浮点数的显示精度（作用）

```c++
//原型
setprecision(int n);
```

指定显示多少位小数（假定对象处于定点模式下）。所有这些设置都将一直保持不变，直到再次调用相应的方法重设置它们。

注：C++的**默认精度**为**6**位(但末尾的0将不显示)

> 2.用法

```c++
#include<iomanip>            //头文件

cout << setprecision(3) << 0.12345 << endl;
cout << setprecision(3) << 1.23456 << endl;
//对应输出为
0.123
1.23
```

注：新的精度设置将**一直有效**，直到被重新设置。

> 3.与fixed并用

fixed()函数与setprecisio(int n)并用，可以控制小数点后面有n位。fixed()函数具有保持功能，后面都将默认为第一次设置的输出格式。

注意：setprecision()函数是**控制有效数字的位数**，而fixed()函数与setprecision(int n )函数**结合使用是保留小数点后的位数**，小数点的保留采用四舍五入，如下所示：

```c++
cout << fixed << setprecision(3) << 0.12345 << endl;
cout << fixed << setprecision(3) << 1.23456 << endl;


cout<<setprecision(2)<<fixed;  //这样也可以
cout<<setiosflags(ios::fixed)<<setprecision(3)<<s; //这样也可以
```

在C++中，fixed主要用于控制浮点数的输出格式。具体用途包括：
控制浮点数的精度：在使用fixed后，输出的浮点数会保持固定的小数位数。例如，使用cout << fixed << setprecision(2) << 3.14159;将输出3.14。
控制浮点数的小数点显示：使用fixed可以确保浮点数输出时带有小数点，不会自动转换为科学计数法。
控制浮点数的位数显示：使用fixed可以确保输出的浮点数有一定的位数，不会自动去掉末尾的0。

#####  5.2 setw(int n)函数

控制输出的字符的宽度n。

```c++
cout << setw(2) << 10497 << endl;
cout << setw(6) << 10497 << endl;
cout << setw(10) << 10497 << endl;
```

对应的输出为:

```c++
10497
 10497
     10497
按任意键继续...
```

若字符的宽度不够则用空格填充。

#### 6.初始化

```c++
#include<cstdio>
int a[2000001];//不要把数组开在主函数里！！
int main()
{
	...
}
```

#### 7.避免MLE的几个方法

```cpp
vector<int> num;
//用vector动态数组节省内存，以防MLE 
//而不是 long long a[100005][100005];
```

#### 8.打表

> 在输入数据比较简单、数据范围不大、输出也比较简单的情况下可以考虑使用。

如果担心某个代码运行速度过慢，可以先在自己的计算机上把答案计算出来，然后记录这些答案，写一个新程序，根据输入不经过计算，直接输出这些记录的答案并提交这个程序。

[P1217 [USACO1.5] 回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)





# 四、排序

#### 1.冒泡排序

基本思想：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。

> 冒泡排序”的原理是：每一趟只能确定将一个数归位。即第一趟只能确定将**末位**上的数（即第 5 位）归位，第二趟只能将倒数第 2 位上的数（即第 4 位）归位，第三趟只能将倒数第 3 位上的数（即第 3 位）归位，而现在前面还有两个位置上的数没有归位，因此我们仍然需要进行“第四趟”。

```c++
//冒泡排序的核心部分
for(int i=0;i<n-1;i++) //n个数排序，只用进行n-1趟
 { 
 	for(int j=0;<n-1-i;j++) //从第1位开始比较直到最后一个尚未归位的数，想一想为什么到n-i就可以了。
 	{ 
 		if(a[j]>a[j+1]) //比较大小并交换
 		{ 
 			t=a[j]; a[j]=a[j+1]; a[j+1]=t;
 		} 
 	} 
 } 
```



#### 2.快速排序

> 首先选择第一个数作为分界数据，将比它小的数据存储在它的左边，将比它大的数据存储在它的右边，它存储在左右两个子集中间。这样左右两个子集就是原问题分解后的独立子问题，再用同样的方法解决这些子问题，直到每个数据只有一个数据，就自然有序了，也就完成了全部数据的排序工作

相关问题：荷兰国旗问题

```c++
#include <iostream> 
int a[101],n;//定义全局变量，这两个变量需要在子函数中使用 
void quicksort(int left,int right) 
{ 
 int i,j,t,temp; 
 if(left>right) 
 return; 
 
 temp=a[left]; //temp中存的就是基准数 
 i=left; 
 j=right; 
 while(i!=j) 
 { 
 //顺序很重要，要先从右往左找 
 while(a[j]>=temp && i<j) 
 j--; 
 //再从左往右找 
 while(a[i]<=temp && i<j) 
 i++; 
 //交换两个数在数组中的位置 
 if(i<j)//当哨兵i和哨兵j没有相遇时
 { 
 t=a[i]; 
 a[i]=a[j]; 
 a[j]=t; 
 } 
 } 
 //最终将基准数归位 
 a[left]=a[i]; 
 a[i]=temp; 
 
 quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 
 quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程 
} 
int main() 
{ 
 int i,j,t; 
 //读入数据 
 cin>>n; 
 for(i=1;i<=n;i++) 
 cin>>a[i]; 
 quicksort(1,n); //快速排序调用 
 
 //输出排序后的结果 
 for(i=1;i<=n;i++) 
 cout <<a[i]; 
 getchar();getchar(); 
 return 0; 
} 
```



> 3.快排3.0版本

```c++
java
public static void quickSort(int [] arr,int L,int R)
{
	if(L<R)
	{
		swap(arr,L+(int)(Math.random()*(R-L+1)),R);
		int[] p=partition(arr,L,R);
		quickSort(arr,L,p[0]-1);
		quickSort(arr,p[1]+1,R);
    }
}
//这是一个处理arr[l...r]的函数
//默认以arr[r]做划分，arr[r]->p     <p    ==p     >p
//返回等于区域(左边界，右边界)，所以返回一个长度为2的数组res,res[0] res[1]
public static int[] partition(int[] arr,int L,int R)
{
	int less=L-1;//<区右边界
	int more=R;//>区左边界
	while(L<more){//L表示当前数的位置 arr[R]  ->   划分值
	if(arr[L]<arr[R]){//当前数<划分值
		swap(arr,++less,L++);
	}else if(arr[L]>arr[R]){
		swap(arr,--more,L);
	}else{
		L++;
	}	
}
swap(arr,more,R);
return new int[]{less+1,more};
}
```



#### 3.乱序算法

```c++
random_shuffle(scores.begin(),scores.end());  //实现乱序操作
```



#### 4.插入排序

> 像打扑克牌一样，遇到相同的插进去，然后从小到大排序

```c++
//核心代码
for(int i=1;i<n;i++){
    int now=a[i],j;      //记录一下待插牌，等下还要放回去
    for(int j=i-1;j>=0;j--)
    {
        if(a[j]>now)
            	a[j+1]=a[j];
        else
            break;
    }
    a[j+1]=now;
}
```



#### 5.二分法

> 采用了分治法，不是必须要有序序列才能使用二分法，无序序列在一定条件下也能使用。

```c++
//金块算法:运用递归实现分半查询 
#include<stdio.h>
float a[5]={3,6,9,2,5};
int main(){
	void maxmin(int i,int j,float &fmax,float &fmin,int &count);//fmax的地址,fmin的地址 
	float fmax=0,fmin=0;
	int count=0;
	maxmin(0,4,fmax,fmin,count);
	//传递地址是为了能够把值带出来 
	printf("fmax=%f\nfmin=%f\ncount=%d\n",fmax,fmin,count); 
	return 0;
}
void maxmin(int i,int j,float &fmax,float &fmin,int &count){
	int mid;
	int k;
	float lmax,lmin,rmax,rmin;
	count++;
	//递归结束条件(子问题的解)
	//当分到只剩一个数
	if(i==j){
		fmax=a[i];fmin=a[i];
	} 
	else if(i==j-1){//(i,j为下标，在分解过程中,i总在左,j总在右 )假如只剩两个数 
		if(a[i]>a[j]){
			fmax=a[i];
			fmin=a[j];
		} 
		else if(a[j]>a[i]){
			fmax=a[j];
			fmin=a[i];
		}
	}
	else{//其他情况（还剩很多数），则继续递归分解 
		mid=(i+j)/2;//继续分半
		maxmin(i,mid,lmax,lmin,count);
		maxmin(mid+1,j,rmax,rmin,count);
		if(lmax>rmax) fmax=lmax;
		else fmax=rmax;
		if(lmin<rmin) fmin=lmin;
		else fmin=rmin;
	}
}
```



#### 6.归并排序

> 归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，**速度仅次于快速排序**，为稳定排序算法，一般用于对总体无序，但是**各子项相对有序**的数列。

```c++
// 归并排序（C++-迭代版）
template<typename T>
void merge_sort(T arr[], int len) {
    T* a = arr;
    T* b = new T[len];
    for (int seg = 1; seg < len; seg += seg) {
        for (int start = 0; start < len; start += seg + seg) {
            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
            int k = low;
            int start1 = low, end1 = mid;
            int start2 = mid, end2 = high;
            //两个都不越界时，谁小拷贝谁
            while (start1 < end1 && start2 < end2)
                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];
            //下面两个while是若一个越界了，然后把另一个没越界的剩余的数全拷贝进去
            while (start1 < end1)                       
                b[k++] = a[start1++];
            while (start2 < end2)
                b[k++] = a[start2++];
        }
        T* temp = a;
        a = b;
        b = temp;
    }
 
    if (a != arr) {
        for (int i = 0; i < len; i++)
            b[i] = a[i];
        b = a;
    }
 
    delete[] b;
}
```



#### 7.堆排序

> 堆排序（Heap Sort）就是对直接选择排序的一种改进。直接选择排序在待排序的n个数中进行n-1次比较选出最大或者最小的，但是在选出最大或者最小的数后，并没有对原来的序列进行改变，这使得下一次选数时还需要对全部数据进行比较，效率大大降低。
>
> [十大经典排序算法----堆排序（超详细） -  CSDN App](http://t.csdnimg.cn/Haxcb)

![QQ图片20240708103642](E:\代码笔记\笔记图片保存\QQ图片20240708103642.png)

![img](file:///C:\Users\wuqian\Documents\Tencent Files\3660692338\Image\C2C\VCKKT677[1OE2M[RQ`P6}S5.png)



#### 8.桶排序

> 1.简单桶排序：(是不基于比较的一种排序，**应用范围较小**)-->**计数排序**
>
> book单词有记录、标记的意思

```c++
 int book[1001],i,j,t,n; 
 for(i=0;i<=1000;i++) 
 book[i]=0; 
 cin>>n;//输入一个数n，表示接下来有n个数
 for(i=1;i<=n;i++)//循环读入n个数，并进行桶排序
 { 
 cin>>t; //把每一个数读到变量t中
 book[t]++; //进行计数，对编号为t的桶放一个小旗子
 } 
 for(i=1000;i>=0;i--) //依次判断编号1000~0的桶
 for(j=1;j<=book[i];j++) //出现了几次就将桶的编号打印几次
 cout<<i; 
```

> 2.基数排序

```c++
public static void radixSort(int[] arr){
	if(arr==null || arr.lenth<2)
	{
		return;
	}
	radixSort(arr,0,arrr.lenth-1,maxbits(arr));
}

public static int maxbits(int[] arr){
	int max=Integer.MIN_VALUE;
	for(int i=0;i<arr.lenth;i++)
	{
		max=Math.max(max,aarr[i]);
	}
	int res=0;
	while(max!=0){
		res++;
		max/=10;
	}
	return res;
}

//arr[begin..end]排序
public static void radixSort(int[] arr,int L,int R,int digit){
	final int radix=10;
	int i=0,j=0;
	//有多少个数准备多少个辅助空间
	int[] bucket=new int[R-L+1];
	for(int d=1;d<=digit;d++){//有多少位就进出几次
	//10个空间
	//count[0] 当前位(d位)是0的数字有多少个
	//count[1] 当前位(d位)是(0和1)的数字有多少个
	//count[2] 当前位(d位)是(0、1和2)的数字有多少个
	//count[i] 当前位(d位)是(0~i)的数字有多少个
	int[] count=new int[radix];//count[0..9]
	for(i=L;i<=R;i++){
		j=getDight[arr[i],d];
		count[j]++;
	}
	for(i=1;i<radix;i++){
		count[i]=count[i]+count[i-1];
	}
	for(i=R;i>=L;i--){
		j=getDight(arr[i],d);
		bucket[count[j]-1]=arr[i];
		count[j]--;
	}
	for(i=L,j=0;i<=R;i++,j++){
		arr[i]=bucket[j];
	}
	}
}
```



#### 9.选择排序

```c++
//核心代码
for(int i==0;i<n-1;i++){
    for(int j=i+1;j<n;j++)
    {
        if(a[i]>a[j])
        {
            t=a[i];
            a[i]=a[j];
            a[j]=t;
        }
    }
}
```

思路：

每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。
实际上，我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。

```c++
//选择排序的高级版本
void swap(int* a, int* b)
{
	int tem = *a;
	*a = *b;
	*b = tem;
}
void SelectSort(int* arr, int n)
{
	//保存参与单趟排序的第一个数和最后一个数的下标
	int begin = 0, end = n - 1;
	while (begin < end)
	{
		//保存最大值的下标
		int maxi = begin;
		//保存最小值的下标
		int mini = begin;
		//找出最大值和最小值的下标
		for (int i = begin; i <= end; ++i)
		{
			if (arr[i] < arr[mini])
			{
				mini = i;
			}
			if (arr[i] > arr[maxi])
			{
				maxi = i;
			}
		}
		//最小值放在序列开头
		swap(&arr[mini], &arr[begin]);
		//防止最大的数在begin位置被换走
		if (begin == maxi)
		{
			maxi = mini;
		}
		//最大值放在序列结尾
		swap(&arr[maxi], &arr[end]);
		++begin;
		--end;
	}
}
```



#### 10.排序算法的稳定性及其汇总

同样值的个体之问，如果不因为排序而改变**相对次序**，就是这个排序是有稳定性的；否则就没有

> **不具备**稳定性的排序：选择排序、快速排序、堆排序

> **具备**稳定性的排序：冒泡排序、插入排序、归井排序、一切桶排序思想下的排序

目前没有找到时问复杂度O(N*1ogN)，额外空间复杂度o(1)，又稳定的排序

| 名称           | 时间复杂度 | 空间复杂度 | 稳定性 |
| -------------- | ---------- | ---------- | ------ |
| 选择排序       | O(N^2)     | O(1)       | ×      |
| 冒泡排序       | O(N^2)     | O(1)       | √      |
| 插入排序       | O(N^2)     | O(1)       | √      |
| 归并排序       | O(N*log N) | O(N)       | √      |
| 快速排序（随） | O(N*log N) | O(log N)   | ×      |
| 堆排序         | O(N*log N) | O(1)       | ×      |



# 五、栈

#### 0.知识补充

> 1.如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一点。

> 栈**仅在表尾**进行操作,是线性表

> 栈支持子程序调用。栈是一种只能在一端进行插入或删除的线性表，在主程序调用子函数时要首先保存主程序当前的状态，然后转去执行子程序，最终把子程序的执行结果返回到主程序中调用子程序的位置，继续向下执行，这种调用符合栈的特点。

##### 0.1中缀表达式转后缀表达式

从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；

若是符号，则判断其与栈顶符号的优先级，是**右括号**或**优先级不高于栈顶符号**（乘除优先加减）则栈顶符号依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

如：“9+(3-1)x3+10/2"转换为"9 3 1-3 * +10 2 / +"。



> 补充：

这里我给出一个中缀表达式：a+b*c-(d+e)

第一步：按照运算符的优先级对所有的运算单位加括号：式子变成了：((a+(b*c))-(d+e))

第二步：转换前缀与后缀表达式

前缀：把运算符号移动到对应的括号前面

则变成了：-( +(a *(bc)) +(de))

把括号去掉：-+a*bc+de 前缀式子出现

后缀：把运算符号移动到对应的括号后面

则变成了：((a(bc)* )+ (de)+ )-

把括号去掉：abc*+de+- 后缀式子出现

##### 0.2 栈的出栈顺序

```java
//一个栈的输入序列为12345，则下列序列中不可能是栈的输出序列的是
```

对于任意栈：1, 2, 3, 4,..., n-1, n，
经过任意顺序的进栈和出栈，也就是栈混洗，
都不能出现  （...,c,...,a,....,b,....）的顺序，其中(a < b < c) ，...代表夹在中间的其他元素。
也就是不能出现 （...大...小...中...） 的顺序。



#### 1.栈的实现

```c++
#include <stdio.h> 
#include <string.h> 
int main() 
{ 
 char a[101],s[101]; 
 int i,len,mid,next,top; 
 
 gets(a); //读入一行字符串
 len=strlen(a); //求字符串的长度
 mid=len/2-1; //求字符串的中点
 
 top=0;//栈的初始化
 //将mid前的字符依次入栈
 for(i=0;i<=mid;i++) 
 s[++top]=a[i]; 
 
 //判断字符串的长度是奇数还是偶数，并找出需要进行字符匹配的起始下标 
 if(len%2==0) 
 next=mid+1; 
 else 
 next=mid+2; 
 
 //开始匹配
 for(i=next;i<=len-1;i++) 
 {
 if(a[i]!=s[top]) 
 break; 
 top--; 
 } 
 
 //如果top的值为0，则说明栈内所有的字符都被一一匹配了
 if(top==0) 
 printf("YES"); 
 else 
 printf("NO"); 
 getchar();getchar(); 
 return 0; 
} 
```

#  六、队列

#### 0.知识补充

> 1.队列 先进先出 （FIFO）
>
> 允许插入的一端称为队尾，允许删除的一端称为队头。

> 2.在可以**确定队列长度**最大值的情况下，建议使用循环队列，如果你无法预估队列的长度，则用链队列



 #### 0.1计算队列长度

```c++
(rear-front+QueueSize)%QueneSize
//rear队尾
//front队头
//QueneSize队列最大长度
```

#### 0.2队列满的条件

```c++
(rear+1)%QueneSize==front
```



#### 1.队列的实现

```c++
//原始代码(STL库中已有队列的实现)
#include <stdio.h> 
struct queue 
{ 
 int data[100];//队列的主体，用来存储内容
 int head;//队首
 int tail;//队尾
};

 
int main() 
{ 
 struct queue q; 
 int i; 
 //初始化队列
 q.head=1; 
 q.tail=1; 
 for(i=1;i<=9;i++) 
 { 
 //依次向队列插入9个数
 scanf("%d",&q.data[q.tail]); 
 q.tail++; 
 } 
 
 while(q.head<q.tail) //当队列不为空的时候执行循环 { 
 //打印队首并将队首出队
 printf("%d ",q.data[q.head]); 
 q.head++; 
 
 //先将新队首的数添加到队尾
 q.data[q.tail]=q.data[q.head]; 
 q.tail++; 
 //再将队首出队
 q.head++; 
 } 
 
 getchar();getchar(); 
 return 0; 
} 

```



# 七、链表

#### 0.知识补充

1.当你传递一个参数给函数时，这个参数会不会在函数内改动决定了使用什么形式。

如果需要被改动，则需要传递指向这个参数的指针。

如果不用被改动，可以直接传递这个参数。

##### 0.1 单链表与单循环链表

单链表又称线性链表。单链表可由头指针唯一确定。因此单链表可以用头指针的名字命名。若头指针名是L，则简称该链表为表L。

单循环链表是循环链表中的一种，循环链表还包括多重链的循环链表。

```apl
若某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用()存储方式最节省运算时间。
A.单链表
B.仅有头指针的单循环链表
C.双链表
D.仅有尾指针的单循环链表
```

1.单链表只能单向遍历，即只能由链表头向链表尾遍历。
2.单循环链表也只能单向遍历：链表头->链表尾->链表头；
对于A,B,C要想在尾端插入结点，需要遍历整个链表。对于D，要插入结点，只要改变一下指针即可，要删除头结点，只要将指针移动到头结点即可。

##### 0.2 顺序存储结构与链式存储结构

> 1.顺序存储结构的地址在内存中是连续的所以可以通过计算地址实现**随机存取**，(线性表的顺序存储结构是一种随机存取的存储结构)

> 2.而链式存储结构的存储地址不一定连续，只能通过第个结点的指针**顺序存取**；

##### 0.3 静态链表

静态链表：定义一个较大的结构数组作为备用结点空间(即存储池)。当申请结点时，每个结点应含有两个域：data域和cur域。data域用来存放结点的数据信息，需注意的是，此时的cur域不再是指针而是游标指示器，游标指示器指示其后继结点在结构数组中的相对位置(即数组下标)。 插入SHI 元素：

![img](file:///C:\Users\wuqian\Documents\Tencent Files\3660692338\Image\C2C\Image1\7912f7d01c14cdcba408cc59971bc212.jpg)



#### 1.链表的各个操作的实现

**结构部分：**

```c
typedef struct LNode { /*线性表的单链表存储*/
	ElemType data;
	struct LNode *next;
} LNode, *LinkList;
```

**1.插入**

```c
//插入功能函数(在链表L的第i个元素前插入元素e)
int insertList(LinkList L, int i, ElemType e) {
	LNode *p1, *pre;
	int k = 0;
	pre = L;
	while (pre->next != NULL && k < i - 1) {
		pre = pre->next;
		k++;
	}
	if (k != i - 1) {
		printf("插入位置不合理\n");
		return (-1);
	}
	p1 = (LNode *)malloc(sizeof(LNode));
	p1->data = e;
	p1->next = pre->next;
	pre->next = p1;
	return (0);
}
```

**2.删除**

```c
//删除功能函数(在链表L中删除第i个元素)
int deleteList(LinkList L, int i) {
	LNode *pre, *p1;
	pre = L;
	int k = 0;
	while (pre->next != NULL && k < i - 1) {
		pre = pre->next;
		k++;
	}
	if (k != i - 1) {
		printf("删除位置不合理\n");
		return ERROR;
	}
	p1 = pre->next;
	pre->next = p1->next;
	return OK;
}
```





#### 2.单链表

单链表的基本技巧，每个技巧都对应着至少一道算法题：

1、合并两个有序链表

2、链表的分解

3、合并 k 个有序链表

4、寻找单链表的倒数第 k 个节点

5、寻找单链表的中点

6、判断单链表是否包含环并找出环起点

7、判断两个单链表是否相交并找出交点 

这些解法都用到了**双指针技巧**，所以说对于单链表相关的题目，双指针的运用是非常广泛的，下面我们就来一个一个看。



##### 2.1 合并两个有序链表

> [21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/)

**题解**（关键部分）：

```c++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    // 虚拟头结点
    ListNode* dummy = new ListNode(-1), *p = dummy;
    ListNode* p1 = l1, *p2 = l2;
    
    while (p1 != NULL && p2 != NULL) {

        // 比较 p1 和 p2 两个指针
        // 将值较小的的节点接到 p 指针
        if (p1->val > p2->val) {
            p->next = p2;
            p2 = p2->next;
        } else {
            p->next = p1;
            p1 = p1->next;
        }
        // p 指针不断前进
        p = p->next;
    }
    
    if (p1 != NULL) {
        p->next = p1;
    }
    
    if (p2 != NULL) {
        p->next = p2;
    }
    
    return dummy->next;
}
```



算法技巧:  **虚拟头节点**

> 当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理。



#### 3.模拟链表

```c++
#include <stdio.h> 
int main() 
{ 
 int data[101],right[101]; 
int i,n,t,len; 
 //读入已有的数 
 scanf("%d",&n); 
 for(i=1;i<=n;i++) 
 scanf("%d",&data[i]); 
 len=n; 
 //初始化数组right 
 for(i=1;i<=n;i++) 
 { 
 if(i!=n) 
 right[i]=i+1; 
 else 
 right[i]=0; 
 } 
 //直接在数组data的末尾增加一个数 
 len++; 
 scanf("%d",&data[len]); 
 
 //从链表的头部开始遍历 
 t=1; 
 while(t!=0) 
 { 
 if(data[right[t]]>data[len])//如果当前结点下一个结点的值大于待插入数，将
数插入到中间 
 { 
 right[len]=right[t];//新插入数的下一个结点标号等于当前结点的下一个结
点编号 
 right[t]=len;//当前结点的下一个结点编号就是新插入数的编号 
 break;//插入完成跳出循环 
 } 
 t=right[t]; 
 } 
 //输出链表中所有的数 
 t=1; 
 while(t!=0) 
 { 
 printf("%d ",data[t]); 
 t=right[t]; 
 } 

```



# 八、串

#### 0.知识补充



  #### 1.KMP模式匹配算法

> 可以大大避免重复遍历的情况。

```c++
/* 通过计算返回子串T的next数组。 /*
void get_next(String T,int *next)
{
	int i,k;
	i=1;
	k=0;
	next[1]=0;
	while(i<T[0])  //此处T[0]表示串T的长度
	{
		if(k==0 || T[i]==T[k])
		{
			++i;
			++k;
			next[i]=k;
		}
		else
			k=next[k];   //若字符不相同，则k值回溯
	}
}
 
/* 返回子串T在主串S中第pos个字符后的位置。若不存在，则函数返回值为0 */
/* T非空，1<=pos<=StrLenth(S) */
int Index_KMP(String S,String T,int pos)
{	
	int i=pos;           //i用于主串S中当前位置下标值，从pos位置开始匹配
	int j=1;             //j用于子串T中当前位置下标值
	int next[255];       //定义-next数组
	get_next(T,next);    //对串T作分析，得到next数组
	while(i<=S[0] && j<=T[0])       //对i小于S的长度并且j小于T的长度时，循环继续
	{
		if(j==0 || S[i]==T[j])      //两字母相等则继续，与朴素算法相比增加了j=0的判断
		{
			++i;
			++j;
		}
		else                        //指针后退重新开始匹配
		{
			j=next[j];              //j退回合适的位置，i值不变  
		}
	}
	if(j>T[0])
		return i-T[0];
	else
		return 0;
}
```



# 九、树

#### 0.知识补充（含二叉树）

>  一种一对多的数据结构 
>
> 树只能有一个根节点
>
> 子树的个数没有限制，但一定互不相交



二叉树遍历的性质：

- 已知**前**序遍历序列和**中**序遍历序列，可以唯一确定一棵二叉树
- 已知**后**序遍历序列和**中**序遍历序列，可以唯一确定一棵二叉树



#### 1.完全二叉树

> **特点：**

1.叶子结点只能出现在最下两层

2.最下层的叶子一定集中在左部连续位置

3.倒数第二层，若有叶子结点，一定都在右部连续位置

4.如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况

5.同样结点数的二叉树，完全二叉树的深度最小



> **性质：**

1.在二叉树的第i层至多2的（i-1）次方个结点

2.深度为k的二叉树至多有2的k次方-1个结点

3.对任何一棵二叉树T，如果其终端结点是n0，度为2的结点数为n2，则n0=n2+1

4.具有n个结点的完全二叉树的深度为[log2 n]+1([x]表示不大于x的最大整数) 

5.如果对一棵有n个结点的完全二叉树（其深度为[log2 n]+1）的结点按层序编号（从第1层到第[log2 n]+1层，每层从左到右），对任一节点i（i<=i<=n）有：

（1）如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点[i/2]；

（2）如果2i>n，则结点i无左孩子（结点i为叶子节点）；否则其左孩子是结点2i

（3）如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1。



#### 2.前序遍历算法

> 规则是若二叉树为空，则空操作返回，否则**先访问根节点**，然后前序遍历左子树，再前序遍历右子树。

```c++
//递归方法
void PreOrderTraverse(BiTree T)
{
	if(T==NULL)
		return;
	printf("%c",T->data);         //显示结点数据，可以更改为其他对结点的操作
	PreOrderTraverse(T->lchild);  //先序遍历左子树
	PreOrderTraverse(T->rchild);  //先序遍历右子树
}
```



#### 3.中序遍历算法

> 规则是若树为空，则空操作返回，否则从根节点开始（注意并不是先访问根节点），**中序遍历根节点的左子树**，然后是访问根节点，最后中序遍历右子树。

```c++
//递归方法
void InOrderTraverse(BiTree T)
{
	if(T==NULL)
		return;
	InOrderTraverse(T->lchild);  //中序遍历左子树
	printf("%c",T->data);        //显示结点数据，可以更改为其他对结点的操作
	InOrderTraverse(T->rchild);  //中序遍历右子树
}
```



#### 4.后序遍历算法

> 规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根节点

```c++
//递归方法
void PostOrderTraverse(BiTree T)
{
	if(T==NULL)
		return;
	PostOrderTraverse(T->lchild);  //后序遍历左子树
	PostOrderTraverse(T->rchild);  //后序遍历右子树
	printf("%c",T->data);          //显示结点数据，可以更改为其他对结点的操作
}
```



# 十、搜索

#### 1.深度优先搜索

> 基本模型

```c++
void dfs(int step)
{
	判断边界
	尝试每一种可能 for(int i=1;i<n;i++)
	{
		继续下一步 dfs(step+1);
	}
	返回 return;
}
```

深度DFS：需要递归，使用顺序栈；


#### 2.广度优先搜索

> 也被称为宽度优先搜索（更适用于所有边的权值相同的情况）

```c++
//炸弹人问题

int next[4][2]={{0,1},{1,0},{0,-1},{-1,0}};   //方便宽度优先探索时向四个方向扩展

//核心部分
while(head<tail)
{
	//枚举四个方向
	for(int k=0;k<4;k++)
	{
		//尝试走的下一个点的坐标
		tx=que[head].x+next[k][0];
		ty=que[head].y+next[k][1];
		
		//判断是否越界
		if(tx<0 || tx>n-1 || ty<0 || ty>m-1)
		continue;
		
		//判断是否为平地或者曾经走过
		if(a[tx][ty]=='.' && book[tx][ty]==0)
		{
			//每个点只入队一次，所以需要标记这个点已经走过
			book[tx][ty]=1;
			//插入新扩展的点到队列中
			que[tail].x=tx;
			que[tail].y=ty;
			tail++;
			
			//统计当前新扩展的点可以消灭的敌人总数
			sum=getnum(tx,ty);      //getnum的功能是统计能炸死的敌人
			//更新max的值
			if(sum>max)
			{
				//如果当前统计出所能消灭的敌人大于max，则更新max，并用mx和my记录该点坐标
				max=sum;
				mx=tx;
				my=ty;
			}
		}
	}
	head++; //当一个点扩展结束后，必须要head++才能对后面的点进行扩展
}
```

广度BFS：类似层次遍历；需要循环队列

# 十一、图

  #### 0.知识补充



  

# 十二、最短路径

#### 1.多源最短路径

时间复杂度:O(N的三次方)

```c++
//Floyd-Warshall算法核心语句
for(int k=1;k<=n;k++)
	for(int i=0;i<=n;i++)
		for(int j=0;j<=n;j++)
			if(e[i][j]>e[i][j]+e[k][j])
				e[i][j]=e[i][k]+e[k][j];
```

> 如何表示正无穷：

我们通常将正无穷定义为99999999（8个9）

在实际应用中最好估计一下最短路径的上限，只需要设置比它大一点就好。

**注:该算法不能解决带有“负权回路”的图**

如：

![QQ图片20240427185727](E:\代码笔记\笔记图片保存\QQ图片20240427185727.jpg)





#### 2.单源最短路径

Dijkstra算法的主要思想：通过边实现松弛。

基本思想：每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。

dis数组的作用：用来记录源点到其余各个顶点的最短路径。

```c++
//Dijkstra算法核心语句
for(int i=0;i<=n-1;i++)
{
	//找到离1号顶点最近的顶点
	min=inf;
	for(int j=0;j<=n;j++)
	{
		if(book[j]==0 && dis[j]<min)
		{
			min=dis[j];
			u=j;
		}
	}
	book[u]=1;
	for(int v=1;v<=n;v++)
	{
		if(e[u][v]<inf)
		{
			if(dis[v]>dis[u]+e[u][v])
				dis[v]=dis[u]+e[u][v];
		}
	}
}
```



#### 3.解决负权边

```c++
//Bellman-Ford算法
for(int k=1;k<=n-1;k++)
	for(int i=1;i<=m;i++)
		if(dis[v[i]]>dis[u[i]]+w[i])
			dis[v[i]]=dis[u[i]]+w[i];
			
//完整代码(优化后)
int main()
{
	int dis[10],bak[10],i,k,n,m,u[10],v[10],w[10],check,flag;
	int inf=99999999;//用inf(infinity的缩写)存储一个我们认为的正无穷值
	//读入n和m，n表示顶点个数，m表示边的条数
	scanf("%d %d",&n,&m);
	
	//读入边
	for(i=i;i<=m;i++)
		scanf("%d %d %d",&u[i],&v[i],&w[i]);
		
	//初始化dis数组，这里是1号顶点到其余各个顶点的初始路程
	for(i=1;i<=n;i++)
		dis[i]=inf;
	dis[1]=0;
	
	//Bellman-Ford算法核心语句
	for(int k=1;k<=n-1;k++)
	{
		//将dis数组备份至bak数组中
		for(int i=1;i<=n;i++) bak[i]=dis[i];
		//进行一轮松弛
		for(i=1;i<=m;i++)
			if(dis[v[i]]>dis[u[i]]+w[i])
				dis[v[i]]=dis[u[i]]+w[i];
		//松弛完毕后检测dis数组是否有更新
		check=0;
		for(i=1;i<=n;i++) if(bak[i]!=dis[i]) {check=1;break;}
		if(check==0) break; //如果dis数组没有更新，提前退出循环结束算法
	}
	//检测负权回路
	flag=0;
	for(i=1;i<=m;i++)
		if(dis[v[i]]>diss[u[i]]+w[i]) flag=1;
		
	if(flag==1) printf("该图含有负权回路");
	else
	{
		//输出最终的结果
		for(i=1;i<=n;i++)
			printf("%d ",dis[i]);
	}	
	getchar();getchar();
	return 0;
}
```

dis数组的作用：用来记录源点到其余各个顶点的最短路径。 



# 十三、算法思路

#### 1.分治算法

> **即将整个问题分解成若干小问题后再分而治之。**如果分解得到的子问题相对来说还是太大，则可反复使用分治策略将这些子问题分成更小的同类型子问题，直至产生方便求解的子问题，必要时逐步合并这些子问题的解，从而得到问题的解。分治算法可以由递归过程来表示，因为分治法就是一种找大规模问题与小规模问题关系的方法，是递归设计的一种具体策略。



- 步骤

**1.分解**
将原问题分解为若干规模较小，相互独立，与原问题相同的子问题。
**2.解决**
若干子问题较小而容易被解决则直接解决，否则再继续分解为更小的子问题，直到容易解决。
**3.合并**
将已求解的各个子问题的解，逐步合并为原问题的解。

有的问题分解后不需要合并子问题的解，此时就不需要再做第3步了。多数问题需要子问题的解，按照题意使用恰当的方法合并成为整个问题的解。需要具体问题具体分析。



- 算法框架

> 分治法的一般算法设计模式如下:

```c++
Divide-and-Conquer(int n){
	if(n<=n0){//n为问题规模 ,n0为可解子问题的规模
		解子问题;
		return(子问题的解);
	}
	for(i=1;i<=k;i++){//分解成较小的子问题p1,p2,...,pk
		yi=Divide-and-Conquer(|Pi|);//递归解决
	}
	T=MERGE(y1,y2,...yk);//合并子问题
	return(T);//返回问题的解
}
```



##### 例题

##### 1.1.1 求第k小的数

> 题目来源:[ 求第k小的数](https://www.luogu.com.cn/problem/P1923)

```c++
//练习分治算法
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
int x[5000005], k;
void qsort(int l, int r)
{
	int i = l, j = r, mid = x[(l + r) / 2];
	do
	{
		while (x[j] > mid)
			j--;
		while (x[i] < mid)
			i++;
		if (i <= j)
		{
			swap(x[i], x[j]);
			i++;
			j--;
		}
	} while (i <= j);
	//特别注意！原本在左边的i到了j右边！中间的区域是数相等的地方！
	//快排后数组被划分为三块： l<=j<=i<=r 
	if (k <= j) qsort(l, j);//在左区间只需要搜左区间
	else if (i <= k) qsort(i, r);//在右区间只需要搜右区间
	else //如果在中间区间直接输出
	{
		printf("%d", x[j + 1]);
		exit(0);
	}
}
int main()
{
	int n;
	scanf("%d%d", &n, &k);
	for (int i = 0; i < n; i++)
		scanf("%d", &x[i]);
	qsort(0, n - 1);
}
```

```c++
//STL库中的nth_element
#include<bits/stdc++.h>
using namespace std;
long long n,k,a[5000010];
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    nth_element(a,a+k,a+n);//使第k小整数就位 
    printf("%d",a[k]);//调用第k小整数
}
```



#### 2.高精度运算

如果需要存储的数字长度超过long long的话，就用数组来模拟非常长的整数。

##### 2.1 高精度加法

[P2437 蜜蜂路线](https://www.luogu.com.cn/problem/P2437)

```c++
#include <cstdio>
using namespace std;
int n, m, len = 1;
int f[1005][1005];

void plus(int x) { 
	for (int i = 1; i <= len; i++)
		f[x][i] = f[x - 1][i] + f[x - 2][i];  //递推
	for (int i = 1; i <= len; i++)   //处理高精度加法
		if (f[x][i] > 9) {
			f[x][i + 1] += f[x][i] / 10;
			f[x][i] %= 10;
		}
	if (f[x][len + 1])
		len++;
}

int main () {
	scanf("%d%d", &m, &n);
	f[1][1] = 1, f[2][1] = 2;
	for (int i = 3; i <= n - m; i++)
		plus(i);
	for (int i = len; i; i--)
		printf("%d", f[n - m][i]);
	return 0;
}
```



各种高精度的模版:

```cpp
#include<stdio.h>
#include<string>
#include<string.h>
#include<iostream>
using namespace std;
//compare比较函数：相等返回0，大于返回1，小于返回-1
int compare(string str1,string str2)
{
    if(str1.length()>str2.length()) return 1;
    else if(str1.length()<str2.length())  return -1;
    else return str1.compare(str2);
}
//高精度加法
//只能是两个正数相加
string add(string str1,string str2)//高精度加法
{
    string str;
    int len1=str1.length();
    int len2=str2.length();
    //前面补0，弄成长度相同
    if(len1<len2)
    {
        for(int i=1;i<=len2-len1;i++)
           str1="0"+str1;
    }
    else
    {
        for(int i=1;i<=len1-len2;i++)
           str2="0"+str2;                //意思是在字符串"0"后面加上str2
    }
    len1=str1.length();
    int cf=0;
    int temp;
    for(int i=len1-1;i>=0;i--)
    {
        temp=str1[i]-'0'+str2[i]-'0'+cf;
        cf=temp/10;
        temp%=10;
        str=char(temp+'0')+str;            //str一开始是空的，将(temp+'0')变为字符串，然后在后面加上str
    }
    if(cf!=0)  str=char(cf+'0')+str;
    return str;
}
//高精度减法
//只能是两个正数相减，而且要大减小
/*string sub(string str1,string str2)//高精度减法
{
    string str;
    int tmp=str1.length()-str2.length();
    int cf=0;
    for(int i=str2.length()-1;i>=0;i--)
    {
        if(str1[tmp+i]<str2[i]+cf)
        {
            str=char(str1[tmp+i]-str2[i]-cf+'0'+10)+str;
            cf=1;
        }
        else
        {
            str=char(str1[tmp+i]-str2[i]-cf+'0')+str;
            cf=0;
        }
    }
    for(int i=tmp-1;i>=0;i--)
    {
        if(str1[i]-cf>='0')
        {
            str=char(str1[i]-cf)+str;
            cf=0;
        }
        else
        {
            str=char(str1[i]-cf+10)+str;
            cf=1;
        }
    }
    str.erase(0,str.find_first_not_of('0'));//去除结果中多余的前导0
    return str;
}
//高精度乘法
//只能是两个正数相乘
string mul(string str1,string str2)
{
    string str;
    int len1=str1.length();
    int len2=str2.length();
    string tempstr;
    for(int i=len2-1;i>=0;i--)
    {
        tempstr="";
        int temp=str2[i]-'0';
        int t=0;
        int cf=0;
        if(temp!=0)
        {
            for(int j=1;j<=len2-1-i;j++)
              tempstr+="0";
            for(int j=len1-1;j>=0;j--)
            {
                t=(temp*(str1[j]-'0')+cf)%10;
                cf=(temp*(str1[j]-'0')+cf)/10;
                tempstr=char(t+'0')+tempstr;
            }
            if(cf!=0) tempstr=char(cf+'0')+tempstr;
        }
        str=add(str,tempstr);
    }
    str.erase(0,str.find_first_not_of('0'));
    return str;
}
//高精度除法
//两个正数相除，商为quotient,余数为residue
//需要高精度减法和乘法
void div(string str1,string str2,string &quotient,string &residue)
{
    quotient=residue="";//清空
    if(str2=="0")//判断除数是否为0
    {
        quotient=residue="ERROR";
        return;
    }
    if(str1=="0")//判断被除数是否为0
    {
        quotient=residue="0";
        return;
    }
    int res=compare(str1,str2);
    if(res<0)
    {
        quotient="0";
        residue=str1;
        return;
    }
    else if(res==0)
    {
        quotient="1";
        residue="0";
        return;
    }
    else
    {
        int len1=str1.length();
        int len2=str2.length();
        string tempstr;
        tempstr.append(str1,0,len2-1);
        for(int i=len2-1;i<len1;i++)
        {
            tempstr=tempstr+str1[i];
            tempstr.erase(0,tempstr.find_first_not_of('0'));
            if(tempstr.empty())
              tempstr="0";
            for(char ch='9';ch>='0';ch--)//试商
            {
                string str,tmp;
                str=str+ch;
                tmp=mul(str2,str);
                if(compare(tmp,tempstr)<=0)//试商成功
                {
                    quotient=quotient+ch;
                    tempstr=sub(tempstr,tmp);
                    break;
                }
            }
        }
        residue=tempstr;
    }
    quotient.erase(0,quotient.find_first_not_of('0'));
    if(quotient.empty()) quotient="0";
}
```



##### 2.5 高精度*单精度

[P1591 阶乘数码](https://www.luogu.com.cn/problem/P1591)

```c++
#include <iostream>
#include <string>
using namespace std;

int a[5000];

int main() {
	int t;
	cin >> t;
	while (t--) {
		int n, aa, j, p, jw;
		long long cn = 0;  //记得cn设置为long long!
		cin >> n >> aa; //p是位数
		//jw是进位
		p = 1;
		for (int i = 0; i < 5000; i++)
			a[i] = 0;
		a[1] = 1;
		for (int i = 2; i <= n; i++) {   //从2开始，反正任何数乘1还等于它本身。
			jw = 0;
			for (j = 1; j <= p; j++) {   //高精度*单精度。
				a[j] = a[j] * i + jw;    //高精度*单精度+进位。
				jw = a[j] / 10;          //设置进位。
				a[j] = a[j] % 10;
			}
			//处理进位
			while (jw > 0) {             //如果还有进位，处理进位。
				a[j] = jw % 10;
				jw /= 10;
				j++;
			}
			p = j - 1;
		}
		for (int i = p; i >= 1; i--) {   //搜索n!里有几个指定数字。(记得i递减且逆序)
			if (a[i] == aa)
				cn++;
		}
		cout << cn << endl;
	}
	return 0;
}
```



##### 2.3 结构体实现高精度

> 高精度与高精度相加，高精度乘低精度

```c++
struct Bigint {
	int len, a[maxn];    //len记录尾数，a记录每个数位
	Bigint(int x = 0) {     //通过初始化将这个大整数存入数组中
		memset(a, 0, sizeof(a));
		for (len = 1; x; len++)
			a[len] = x % 10, x /= 100;
		len--;
	}
	int &operator[](int i) {    //重载[],可以直接用x[i]代表x.a[i]
		return a[i];
	}
	void flatten(int L) {       //处理1到L范围内的进位并重置长度,需要保证L不小于有效长度
		len = L;
		for (int i = 1; i <= len; i++)
			a[i + 1] += a[i] / 10, a[i] %= 10;
		for (; !a[len];)         //重置长度成为有效长度
			len--;
	}
	void print() {
		for (int i = max(len, 1); i >= 1; i--)
			printf("%d", a[i]);
	}
};

Bigint operator+(Bigint a, Bigint b) {
	Bigint c;
	int len = max(a.len, b.len);
	for (int i = 1; i <= len; i++)
		c[i] += a[i] + b[i];
	c.flatten(len + 1);
	return c;
}

Bigint operator*(Bigint a, int b) {
	Bigint c;
	int len = a.len;
	for (int i = 1; i <= len; i++)
		c[i] = a[i] * b;
	c.flatten(len + 11);         //int类型最长10位，用这样做一遍"展平"处理进位
	return c;
}
```





#### 3. 暴力--子集枚举(位运算)

子集与二进制有着密不可分的关系。

枚举子集的算法时间复杂度是O(2^n)，一般情况下1秒钟可以枚举包含**20~30个**元素的集合的子集。在枚举的时候，如果对顺序有要求，就要确定枚举的方向和每一位代表什么元素。

> 一些集合常用的关系:
>
> - 并集：A1的每一位都等于对应位A2 or A3的结果。
>
> 对应位运算  a1=a2 | a3;
>
> - 交集：A3是A1和A4的交集
>
> a3=a1 & a4
>
> - 包含：A2所有的元素都在A1中出现
>
> 对应位运算  (a1 | a2==a1)&&(a1 & a2==a2)
>
> - 属于：如果要判断第i个元素是否属于A1，可以写成(A1 & (1<<i))
> - 补集：A3的补集可以表示为a^a2;(^是异或运算)



**注意:此方法要在n很小(20左右)的情况才能用，n如果在100左右的话会超时！！！**

[(45分)暴力枚举为啥过不了啊T^T](https://www.luogu.com.cn/discuss/957478)



例一：

[P1036 [NOIP2002 普及组] 选数](https://www.luogu.com.cn/problem/P1036)

```c++
#include <iostream>
#include <string>
using namespace std;

bool check(int n) {
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0)
			return 0;
	}
	return 1;
}

int main() {
	int n, k, cn = 0;
	cin >> n >> k;
	int a[n];
	for (int i = 0; i < n; i++)
		cin >> a[i];
	int U = 1 << n;
	for (int S = 0; S < U; S++) { //枚举U-1
		if (__builtin_popcount(S) == k) {
			int sum = 0;
			for (int i = 0; i < n; i++) {
				if (S & (1 << i))
					sum += a[i];	
			}if (check(sum))
					cn++;
		}

	}
	cout << cn << endl;
	return 0;
}
```



例二：

[P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)

```c++
#include <iostream>
#include <string>
#include <iomanip>
using namespace std;
int a[50];

int main() {
	int n, r;
	cin >> n >> r;
    
	for (int i = (1 << n) - 1; i >= 0; i--) {    //从全集枚举到0
		int cn = 0;
		for (int j = 0; j < n; j++) {
			if (i & (1 << j)) {   //如果第j个数在i中
				a[cn++] = j;
			}
		}
		if (cn == r) {
			for (int z = cn - 1; z >= 0; z--)
				cout << setw(3) << n - a[z];     //因为要用高位表示1，所以需要反过来输出
			cout << endl;
		}
	}
	return 0;
}
```



例三：

[P2036 [COCI2008-2009 #2] PERKET](https://www.luogu.com.cn/problem/P2036)

> 用二进制数表示配料的选择情况，例如有5种配料，二进制数0110101101则表示选择第1、3、4种配料（从右往左）。
>
> 可通过`(a>>j)&1`判断从右往左数第*j*位(二进制)是不是1。
>
> 最后计算出酸度和甜度的绝对差，取最小值。

```c++
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
int s[15], b[15];
int Min = 1000000001;

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> s[i] >> b[i];

	for (int i = 1; i < (1 << n); i++) {
		int S = 1, B = 0;
		for (int j = 0; j < n; j++) {
			if ((i >> j) & 1) {
				S *= s[j];
				B += b[j];
			}
		}
		Min = min(Min, abs(S - B));
	}
	cout << Min << endl;
	return 0;
}
```



#### 4.递推思想

> 当就某个问题能写出递推式、能确定初始(边界)条件，那么可以考虑使用递推。对于某些数据规模较大的递推任务可以使用矩阵加速提升效率。

[P1002 [NOIP2002 普及组] 过河卒](https://www.luogu.com.cn/problem/P1002)

```
#include <iostream>
#define MAXN 22
using namespace std;

long long f[MAXN][MAXN] = {0};
int ctrl[MAXN][MAXN], n, m, hx, hy;
int d[9][2] = {{0, 0}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}, {2, 1}, {2, -1}, {-2, 1}, {-2, -1}};

int main() {
	cin >> n >> m >> hx >> hy;
	ctrl[hx][hy] = 1;
	for (int i = 0; i < 9; i++) {
		int tx = hx + d[i][0];
		int ty = hy + d[i][1];
		if(tx>=0 && tx<=n && ty>=0 && ty<=m)
		ctrl[tx][ty] = 1;
	}
	f[0][0] = 1 - ctrl[0][0];
	for (int i = 0; i <= n; i++) {
		for (int j = 0; j <= m; j++) {
			if (ctrl[i][j])
				continue;
			if (i != 0)
				f[i][j] += f[i - 1][j];
			if (j != 0)
				f[i][j] += f[i][j - 1];
		}
	}
	cout << f[n][m] << endl;
	return 0;
}
```



类似例题:

[P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)



#### 5.递归思想

> 如果能将一个大的任务分解成若干规模较小的任务，而且这些任务的形式与结构和原问题一致，就可以考虑使用递归。当问题规模足够小或者达到了边界条件就要停止递归。分解完问题后还要对这些规模小的任务合并然后返回解，最后逐级上报，解决最大规模的问题。有些问题使用递推策略和递归策略都能解决，但有些问题只能将大问题分割成小问题，但是却很难建立递推式，在这种情况下应使用递归策略。



[P1928 外星密码](https://www.luogu.com.cn/problem/P1928)

```c++
#include <iostream>
#include <string>
using namespace std;

string expand() {
	string s = "", b;
	int X;
	char c;
	while (cin >> c) {
		if (c == '[') {
			cin >> X;
			b = expand();
			while (X--) {
				s += b;
			}
		} else if (c == ']')
			return s;
		else
			s += c;
	}
	return s;
}

int main() {
	cout << expand();
	return 0;
}
```



#### 6.贪心思想

证明贪心的**方法：**

- 假设要选择的方案不是贪心算法所要求的方案，只需要证明将需要贪心的方案替换掉所选择方案，结果会更好。
- 



# 十四、错题本总结

#### 1.结构体

[P1093 [NOIP2007 普及组] 奖学金](https://www.luogu.com.cn/problem/P1093)

```c++
#include<iostream>
#include<algorithm>
using namespace std;
struct stu
{
    int num;
    int c, m, e;
    int sum;
}student[310];
bool cmp(stu a, stu b)
{
    if (a.sum > b.sum) return 1;
    else if (a.sum < b.sum) return 0;
    else
    {
        if (a.c > b.c) return 1;
        else if (a.c < b.c) return 0;
        else
        {
            if (a.num > b.num) return 0;
            else return 1;
        }
    }
}
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        student[i].num = i;//录入编号
        cin >> student[i].c >> student[i].m >> student[i].e;//输入
        student[i].sum = student[i].c + student[i].m + student[i].e;//计算总分
    }
    sort(student + 1, student + 1 + n, cmp);
    for (int i = 1; i <= 5; i++)
        cout << student[i].num << ' ' << student[i].sum << endl;
    return 0;
}
```



#### 2.字符串处理超过100位数的输入

[P1781 宇宙总统](https://www.luogu.com.cn/problem/P1781)

```c++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
string a[25];
int number;

int main() {
	int n;
	cin >> n;
	string max = "";
	number = 0;
	for (int i = 0; i < n; i++) {
		string temp;
		cin >> temp;
		int inSize = temp.size();
		int maxSize = max.size();
		if (maxSize < inSize || (inSize == maxSize && temp > max) ) {  //若位数相同则按照正常字典序比较(即条件2)
			max = temp;
			number = i;
		}
	}

	cout << number + 1 << endl;
	cout << max << endl;
	return 0;
}
```



#### 3.用bool确定每个数是否加上了

##### Lost Permutation

[丢失的排列](https://www.luogu.com.cn/problem/CF1759B)

```c++
#include <iostream>
#include <cstring>
using namespace std;
int t;
bool flag;
int m, s, mx;
bool vis[5005];
bool check() {
    for (int i = 1; i <= mx; i++) { // 判断有没有补全
        if (!vis[i]) return false;
    }
    return true;
}
void work() {
    int cnt = 0, sum = 0;
    for (int i = 1; ; i++) {
        if (!vis[i]) {
            cnt++; sum += i;
            vis[i] = 1;
        }
        if (sum == s && check()) { // 是否合法 && 是否可行？
            flag = true;
            return ;
        }
        if (sum > s) return ; // 超过则直接 false
    }
}
int main() {
    cin >> t;
    while (t--) {
        cin >> m >> s;
        memset(vis, 0, sizeof(vis));
        flag = 0; mx = 0;
        for (int i = 1; i <= m; i++) {
            int tmp; cin >> tmp;
            mx = max(mx, tmp); // 记最大数
            vis[tmp] = true; // 标记
        }
        work();
        if (flag) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}
```

#### 4.模拟题

##### 4.1 矩阵旋转

[P4924 [1007] 魔法少女小Scarlet](https://www.luogu.com.cn/problem/P4924)

> **第i行第j个** 变成**倒数第i列第j个** 顺时针 

> **第i行第j个** 变成**第i列倒数第j个** 逆时针 

```c++
#include <bits/stdc++.h>
using namespace std;
int g[510][510], tot, f[510][510]; //f数组充当临时数组

int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			g[i][j] = ++tot;
	for (int i = 1; i <= m; i++) {
		int a, b, r, opt;
		scanf("%d %d %d %d", &a, &b, &r, &opt); //下面的分析都是针对那一块矩阵而言的
		if (opt == 0) { //第i行第j个 变成倒数第i列第j个 顺时针
			for (int i = a - r; i <= a + r; i++)
				for (int j = b - r; j <= b + r; j++)          //找到需要旋转的矩阵的第一行和第一列
					f[a - b + j][a + b - i] = g[i][j];
			for (int i = a - r; i <= a + r; i++)
				for (int j = b - r; j <= b + r; j++)
					g[i][j] = f[i][j];
		} else { //第i行第j个 变成第i列倒数第j个 逆时针
			for (int i = a - r; i <= a + r; i++)
				for (int j = b - r; j <= b + r; j++)
					f[a + b - j][b - a + i] = g[i][j];
			for (int i = a - r; i <= a + r; i++)
				for (int j = b - r; j <= b + r; j++)
					g[i][j] = f[i][j];
		}
	}
	for (int i = 1; i <= n; i++) { //输出结果咯
		for (int j = 1; j <= n; j++)
			printf("%d ", g[i][j]);
		printf("\n");
	}
	return 0;
}
```

